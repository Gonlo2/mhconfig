syntax = "proto3";

package mhconfig.proto;

service MHConfig {
  // Public methods
  rpc Get(GetRequest) returns (GetResponse);
  rpc Watch(stream WatchRequest) returns (stream WatchResponse);

  // Admin methods
  rpc Update(UpdateRequest) returns (UpdateResponse);
  rpc RunGC(RunGCRequest) returns (RunGCResponse);
}


message GetRequest {
  // the root path of the namespace to obtain the configuration.
  string root_path = 1;
  // the list of overrides to apply from lower to higher priority.
  repeated string overrides = 2;
  // the version of the configuration to retrieve, it retrieve the latest
  // version with a zero value and the proper version otherwise.
  uint32 version = 3;
  // the key to retrieve and it must have at least one element.
  repeated string key = 4;
}

message GetResponse {
  enum Status {
    OK = 0;
    ERROR = 1;
    // has been requested a removed or inexistent version.
    INVALID_VERSION = 2;
    // in the case of use the `ref` tag, the dependency graph have a cycle.
    REF_GRAPH_IS_NOT_DAG = 3;
  }
  Status status = 1;
  uint64 namespace_id = 2;
  // the returned version, it's the last version if the asked version was the zero.
  uint32 version = 3;
  repeated Element elements = 4;
}


message UpdateRequest {
  // the root path of the namespace that has been changed.
  string root_path = 1;
  // the list of paths to check for changes, this apply to creations, modifications and deletions.
  repeated string relative_paths = 2;
}

message UpdateResponse {
  uint64 namespace_id = 1;
  enum Status {
    OK = 0;
    ERROR = 1;
  }
  Status status = 2;
  // the new version.
  uint32 version = 3;
}


message RunGCRequest {
  enum Type {
    CACHE_GENERATION_0 = 0;
    CACHE_GENERATION_1 = 1;
    CACHE_GENERATION_2 = 2;
    DEAD_POINTERS = 3;
    NAMESPACES = 4;
    VERSIONS = 5;
  }
  Type type = 1;
  uint32 max_live_in_seconds = 2;
}

message RunGCResponse {
}


message WatchRequest {
  // the id to assign to the watcher (this is assigned by the client).
  uint32 uid = 1;
  // if the purpose of the call is remove the watcher with the provided uid.
  bool remove = 2;
  // the root path of the namespace to obtain the configuration.
  string root_path = 3;
  // the list of overrides to apply from lower to higher priority.
  repeated string overrides = 4;
  // the last know version of the configuration, in the case of zero the server
  // will reply the latest one, in other case the server will reply when exists
  // a newer version that change the configuration. Please note that this means
  // that the server can skip several versions if the server don't change the
  // requested document directly or indirectly
  uint32 version = 5;
  // document to watch.
  string document = 6;
}

message WatchResponse {
  // the id assigned to the watcher.
  uint32 uid = 1;
  enum Status {
    OK = 0;
    ERROR = 1;
    // has been requested a removed or inexistent version
    INVALID_VERSION = 2;
    // in the case of use the `ref` tag, the dependency graph have a cycle.
    REF_GRAPH_IS_NOT_DAG = 3;
    // the provided uid is already in use.
    UID_IN_USE = 4;
    // the provided uid don't exists in the system.
    UNKNOWN_UID = 5;
    // the provided has been removee, keep in mind that it's possible to have
    // career conditions in this method if:
    // - a file has been changed and processing of the watcher has begun
    // - an watcher has been requested to be removed
    // - it's returned that the watcher has been removed
    // - a configuration with the removed watcher identifier is returned
    REMOVED = 6;
  }
  Status status = 2;
  uint64 namespace_id = 3;
  uint32 version = 4;
  repeated Element elements = 5;
}


message Element {
  enum NodeType {
    SCALAR_NODE = 0;
    MAP_NODE = 1;
    SEQUENCE_NODE = 2;
    NULL_NODE = 3;
    UNDEFINED_NODE = 4;
  }
  NodeType type = 1;
  uint32 sibling_offset = 2;
  uint32 size = 3;
  string key = 4;
  string value = 5;
}

// SCALAR
//   Element{type: SCALAR_NODE, value: XXX, sibling_offset: 0}
// MAP
//   Element{type: MAP_NODE, size: 2, sibling_offset: 0}
//     Element{type: SEQUENCE_NODE, key: XXX, size: 1, sibling_offset: 2}
//       Element{type: SEQUENCE_NODE, size: 0, sibling_offset: 0}
//     Element{type: NULL_NODE, key: YYY, sibling_offset: 0}
// SEQUENCE
//   Element{type: SEQUENCE_NODE, size: 1, sibling_offset: 0}
//     Element{type: SEQUENCE_NODE, size: 1, sibling_offset: 0}
//       Element{type: MAP_NODE, size: 0, sibling_offset: 0}
// NULL
//   Element{type: NULL_NODE, sibling_offset: 0}
// UNDEFINED
//   Element{type: UNDEFINED_NODE, sibling_offset: 0}
