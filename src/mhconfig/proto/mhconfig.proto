syntax = "proto3";

package mhconfig.proto;

option cc_enable_arenas = true;

service MHConfig {
  // Public methods
  rpc Get(GetRequest) returns (GetResponse);
  rpc Watch(stream WatchRequest) returns (stream WatchResponse);

  // Admin methods
  rpc Update(UpdateRequest) returns (UpdateResponse);
  rpc RunGC(RunGCRequest) returns (RunGCResponse);
}


message GetRequest {
  // the root path of the namespace to obtain the configuration.
  string root_path = 1;
  // the list of overrides to apply from lower to higher priority.
  repeated string overrides = 2;
  // the list of flavors to apply from lower to higher priority.
  repeated string flavors = 6;
  // the version of the configuration to retrieve, it retrieve the latest
  // version with a zero value and the proper version otherwise.
  uint32 version = 3;
  // the document to retrieve
  string document = 4;
  // the template to render with the requested config, none if it isn't defined
  string template = 5;
}

message GetResponse {
  enum Status {
    OK = 0;
    ERROR = 1;
    // has been requested a removed or inexistent version.
    INVALID_VERSION = 2;
    // in the case of use the `ref` tag, the dependency graph have a cycle.
    REF_GRAPH_IS_NOT_DAG = 3;
  }
  Status status = 1;
  uint64 namespace_id = 2;
  // the returned version, it's the last version if the asked version was the zero.
  uint32 version = 3;
  repeated Element elements = 4;
  string template_rendered = 5;
}


message UpdateRequest {
  // the root path of the namespace that has been changed.
  string root_path = 1;
  // the list of paths to check for changes, this apply to creations,
  // modifications and deletions.
  repeated string relative_paths = 2;
  // reload all the config files of the namespace, if this flag is
  // on the relative_paths are ignored
  bool reload = 3;
}

message UpdateResponse {
  uint64 namespace_id = 1;
  enum Status {
    OK = 0;
    ERROR = 1;
  }
  Status status = 2;
  // the new version.
  uint32 version = 3;
}


message RunGCRequest {
  enum Type {
    CACHE_GENERATION_0 = 0;
    CACHE_GENERATION_1 = 1;
    CACHE_GENERATION_2 = 2;
    DEAD_POINTERS = 3;
    NAMESPACES = 4;
    VERSIONS = 5;
  }
  Type type = 1;
  uint32 max_live_in_seconds = 2;
}

message RunGCResponse {
}


message WatchRequest {
  // the id to assign to the watcher (this is assigned by the client).
  uint32 uid = 1;
  // if the purpose of the call is remove the watcher with the provided uid.
  bool remove = 2;
  // the root path of the namespace to obtain the configuration.
  string root_path = 3;
  // the list of overrides to apply from lower to higher priority.
  repeated string overrides = 4;
  // the list of flavors to apply from lower to higher priority.
  repeated string flavors = 8;
  // the last know version of the configuration, in the case of zero the server
  // will reply the latest one, in other case the server will reply when exists
  // a newer version that change the configuration. Please note that this means
  // that the server can skip several versions if the server don't change the
  // requested document directly or indirectly
  uint32 version = 5;
  // document to watch.
  string document = 6;
  // the template to render with the requested config, none if it isn't defined
  string template = 7;
}

message WatchResponse {
  enum Status {
    OK = 0;
    // if some error take place the watcher will be removed
    ERROR = 1;
    // has been requested a removed or inexistent version
    INVALID_VERSION = 2;
    // in the case of use the `ref` tag, the dependency graph have a cycle.
    REF_GRAPH_IS_NOT_DAG = 3;
    // the provided uid is already in use.
    UID_IN_USE = 20;
    // the provided uid don't exists in the system.
    UNKNOWN_UID = 21;
    // the provided uid has been removed, keep in mind that it's possible
    // to have career conditions in this method if:
    // - a file has been changed and processing of the watcher has begun
    // - an watcher has been requested to be removed
    // - it's returned that the watcher has been removed
    // - a configuration with the removed watcher identifier is returned
    // PS: the server could remove the watcher if the namespace has been
    // deleted and it's the client responsibility to re-register if it
    // wish to do so
    REMOVED = 22;
  }
  Status status = 1;
  uint64 namespace_id = 2;
  uint32 version = 3;
  // The uid of the elements need be the same of the request
  // to allow reuse the serialization cache
  repeated Element elements = 4;
  string template_rendered = 5;

  // the id assigned to the watcher.
  uint32 uid = 10;
}


// The type is stored has two groups, the type of the node
// (four less significative bits) and the type of the key
// (tree most significative).
//   Value group:
//   - String: 0
//   - Undefined: 1
//   - Integer: 2
//   - Float: 3
//   - Boolean: 4
//   - Null: 5
//   - Map: 6
//   - Sequence: 7
//   Key group:
//   - String: 0
// PS: The idea of use 7 bits is to use only one byte to
// encode the data (protobuf use the last bit to know if
// The value don't fit in the actual byte)

message Element {
  uint32 type = 1;
  uint32 sibling_offset = 2;
  uint32 size = 3;
  oneof value {
    string value_str = 4;
    sint64 value_int = 5;
    bool value_bool = 6;
    double value_float = 7;
  }
  oneof key {
    string key_str = 8;
  }
}

// SCALAR
//   Element{type: SCALAR_NODE, value: XXX, sibling_offset: 0}
// MAP
//   Element{type: MAP_NODE, size: 2, sibling_offset: 0}
//     Element{type: SEQUENCE_NODE, key: XXX, size: 1, sibling_offset: 2}
//       Element{type: SEQUENCE_NODE, size: 0, sibling_offset: 0}
//     Element{type: NULL_NODE, key: YYY, sibling_offset: 0}
// SEQUENCE
//   Element{type: SEQUENCE_NODE, size: 1, sibling_offset: 0}
//     Element{type: SEQUENCE_NODE, size: 1, sibling_offset: 0}
//       Element{type: MAP_NODE, size: 0, sibling_offset: 0}
// NULL
//   Element{type: NULL_NODE, sibling_offset: 0}
// UNDEFINED
//   Element{type: UNDEFINED_NODE, sibling_offset: 0}
