syntax = "proto3";

package mhconfig.proto;

option cc_enable_arenas = true;

service MHConfig {
  // Public methods
  rpc Get(GetRequest) returns (GetResponse);
  rpc Watch(stream WatchRequest) returns (stream WatchResponse);

  // Admin methods
  rpc Update(UpdateRequest) returns (UpdateResponse);
  rpc RunGC(RunGCRequest) returns (RunGCResponse);
  rpc Trace(TraceRequest) returns (stream TraceResponse);
}

message Label {
  string key = 1;
  string value = 2;
}

message GetRequest {
  // the root path of the namespace to obtain the configuration.
  string root_path = 1;
  // the list of labels to apply.
  repeated Label labels = 2;
  // the version of the configuration to retrieve, it retrieve the latest
  // version with a zero value and the proper version otherwise.
  uint32 version = 3;
  // the document to retrieve
  string document = 4;
}

message GetResponse {
  enum Status {
    OK = 0;
    ERROR = 1;
    // has been requested a removed or inexistent version.
    INVALID_VERSION = 2;
    // in the case of use the `ref` tag, the dependency graph have a cycle.
    REF_GRAPH_IS_NOT_DAG = 3;
  }
  Status status = 1;
  uint64 namespace_id = 2;
  // the returned version, it's the last version if the asked version was the zero.
  uint32 version = 3;
  repeated Element elements = 4;
  // A checksum of the file content, being a sha256 checksum the current implementation
  bytes checksum = 5;
}


message UpdateRequest {
  // the root path of the namespace that has been changed.
  string root_path = 1;
  // the list of paths to check for changes, this apply to creations,
  // modifications and deletions.
  repeated string relative_paths = 2;
  // reload all the config files of the namespace, if this flag is
  // on the relative_paths are ignored
  bool reload = 3;
}

message UpdateResponse {
  uint64 namespace_id = 1;
  enum Status {
    OK = 0;
    ERROR = 1;
  }
  Status status = 2;
  // the new version.
  uint32 version = 3;
}


message RunGCRequest {
  enum Type {
    CACHE_GENERATION_0 = 0;
    CACHE_GENERATION_1 = 1;
    CACHE_GENERATION_2 = 2;
    DEAD_POINTERS = 3;
    NAMESPACES = 4;
    VERSIONS = 5;
  }
  Type type = 1;
  uint32 max_live_in_seconds = 2;
}

message RunGCResponse {
}


message WatchRequest {
  // the id to assign to the watcher (this is assigned by the client).
  uint32 uid = 1;
  // if the purpose of the call is remove the watcher with the provided uid.
  bool remove = 2;
  // the root path of the namespace to obtain the configuration.
  string root_path = 3;
  // the list of labels to watch.
  repeated Label labels = 4;
  // document to watch.
  string document = 5;
}

message WatchResponse {
  enum Status {
    OK = 0;
    // if some error take place the watcher will be removed
    ERROR = 1;
    // has been requested a removed or inexistent version
    INVALID_VERSION = 2;
    // in the case of use the `ref` tag, the dependency graph have a cycle.
    REF_GRAPH_IS_NOT_DAG = 3;
    // the provided uid is already in use.
    UID_IN_USE = 20;
    // the provided uid don't exists in the system.
    UNKNOWN_UID = 21;
    // the provided uid has been removed, keep in mind that it's possible
    // to have career conditions in this method if:
    // - a file has been changed and processing of the watcher has begun
    // - an watcher has been requested to be removed
    // - it's returned that the watcher has been removed
    // - a configuration with the removed watcher identifier is returned
    // PS: the server could remove the watcher if the namespace has been
    // deleted and it's the client responsibility to re-register if it
    // wish to do so
    REMOVED = 22;
    // the provided token don't have the permisions to watch the asked document.
    PERMISSION_DENIED = 23;
    // some of the provided arguments are invalid.
    INVALID_ARGUMENT = 24;
  }
  Status status = 1;
  uint64 namespace_id = 2;
  uint32 version = 3;
  // The uid of the elements need be the same of the request
  // to allow reuse the serialization cache
  repeated Element elements = 4;
  // A checksum of the file content, being a sha256 checksum the current implementation
  bytes checksum = 5;

  // the id assigned to the watcher.
  uint32 uid = 10;
}


// The trace request parameters can be seen as a python conditional like
//   (labels is empty or labels is a subset of A)
//   and (document is empty or document == B)
// where
//   A is a label got/watched
//   B is a document got/watched
message TraceRequest {
  // the root path of the namespace where trace the configuration.
  string root_path = 1;
  // the list of labels to trace, if some document with one of them
  // is asked it will be returned
  repeated Label labels = 2;
  // the document to trace, in case it is not defined it will not be used
  // in the query
  string document = 3;
}

message TraceResponse {
  enum Status {
    RETURNED_ELEMENTS = 0;
    ERROR = 1;
    ADDED_WATCHER = 2;
    EXISTING_WATCHER = 3;
    REMOVED_WATCHER = 4;
  }
  Status status = 1;
  uint64 namespace_id = 2;
  uint32 version = 3;
  repeated Label labels = 4;
  string document = 5;
}


// The type is stored has two groups, the type of the node
// (four less significative bits) and the type of the key
// (tree most significative).
//   Value group:
//   - String: 0
//   - Undefined: 1
//   - Integer: 2
//   - Float: 3
//   - Boolean: 4
//   - Null: 5
//   - Map: 6
//   - Sequence: 7
//   - Binary: 8
//   Key group:
//   - String: 0
// PS: The idea of use 7 bits is to use only one byte to
// encode the data (protobuf use the last bit to know if
// The value don't fit in the actual byte)

message Element {
  uint32 type = 1;
  uint32 sibling_offset = 2;
  uint32 size = 3;
  oneof value {
    string value_str = 4;
    sint64 value_int = 5;
    bool value_bool = 6;
    double value_double = 7;
    bytes value_bin = 9;
  }
  oneof key {
    string key_str = 8;
  }
}
